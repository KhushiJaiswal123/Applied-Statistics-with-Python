---
title: "Resources"
toc: true
toc-title: "Contents"
toc-location: left
format: html
jupyter: python3
---

::: {.callout-tip collapse=false}

## Contents

- [Pre-Programme Setup](#preprogramme)
- [DataCamp Courses](#datacamp)
- [Installing uv](#uv)
- [Getting Started with the Console](#console)
- [Managing Python & Projects](#projects)
- [Visual Studio Code](#vscode)
- [Pre-Programme Assignment](#assignment)

:::

<!--#################################################-->

# **Pre-Programme Setup** {#preprogramme}

Python is an open-source, versatile, high-level programming language known for its simplicity and readability.  
Widely used in web development, data analysis, artificial intelligence, and automation, Python empowers both beginners and professionals to build powerful applications efficiently.  

In this course, we‚Äôll use modern Python development tools that are faster, more efficient, and easier to manage than traditional approaches:

- **uv**: A lightning-fast Python package manager and project manager written in Rust  
- **Visual Studio Code**: A powerful, free code editor with excellent Python support and rich extension ecosystem  

üìß Questions or issues? Please contact **kchristodoulou@london.edu**. It‚Äôs easy to get stuck when starting, so don‚Äôt hesitate to reach out.  


<!--#################################################-->

# **DataCamp Courses** {#datacamp}

- You should have received an invitation to the **DataCamp group "Applied Stats with Python"** using your LBS email.  
- You are required to complete a couple of DataCamp courses (3‚Äì4 hours each).  
- You can stop midway and resume later; only completion matters (not hints/solutions used).  
- Take notes if you find it useful, but the key is **practice over perfection**.  
- Complete all videos **before the deadline**.  
- Once finished, proceed with software installation.  

<!--#################################################-->

# **Installing uv** {#uv}

**uv** is a fast Python package/project manager written in Rust, designed to replace pip, virtualenv, poetry, and others.  

### Why uv?
- üöÄ **Speed**: 10‚Äì100x faster than pip  
- üõ† **All-in-one**: Handles environments & Python versions  
- üì¶ **Modern**: Uses `pyproject.toml`  
- üíª **Cross-platform**: Works on Windows, macOS, Linux

### Installation
**Windows**  
```powershell
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"

```

**macOS/Linux**  
```bash
curl -LsSf https://astral.sh/uv/install.sh | sh

```

**macOS with Homebrew**  
```bash
brew install uv

```

**Verify Installation**  
```bash
uv --version

```

<!--#################################################-->

## **Getting Started with the Console** {#console}

Think of the console (a.k.a. terminal, command prompt, or shell) as a way to ‚Äútalk‚Äù directly to your computer using text commands.

### Windows

- Open PowerShell / Command Prompt ([step-by-step guide](https://www.digitalcitizen.life/open-cmd/))  
- Navigate to your project folder  
- Test installation:  

```bash
uv --version
```

**macOS** 

 - [Open Terminal](https://www.wikihow.com/Get-to-the-Command-Line-on-a-Mac)
 - Test installation:
 
```bash
uv --version

```
- Ignore any warnings about ‚Äúzsh.‚Äù

<!--#################################################-->

## Managing Python & Projects with uv {#projects}

One of uv‚Äôs best features is automatic Python management. You don‚Äôt even need to install Python, you can do it through uv!

### Installing Python

```bash
uv python install          # Install the latest Python version
uv python install 3.13     # Install a specific version
uv python list             # List available versions
```
### Creating a New Project

```bash
uv init my-project
cd my-project

```

This will create:
 - pyproject.toml (project configuration)
 - README.md (project documentation)
 - main.py (sample Python file)
 - .gitignore (Git ignore file)
 - .python-version (Python version specification)

### Adding Dependencies

Instead of manually managing virtual environments, uv handles everything automatically. Open the terminal, and please go to the folder where you set up my-project.

```bash
uv add numpy pandas matplotlib scikit-learn seaborn statsmodels gapminder nycflights13
uv add --dev pytest jupyter utils


```
This will: 

 - Create a virtual environment (if none exists)
 - Install the specified packages
 - Update pyproject.toml
 - Create/update uv.lock for reproducibility

### Running Python Code
```bash
uv run python main.py

```
### Synchronizing Environments
When switching between machines or working with others:
```bash
uv sync

```

This ensures your environment matches exactly what‚Äôs specified in the lock file. (This has been a life saver for me switching between my work and home machines.)

### Virtual Environment Management
```bash
uv venv

```

Activate the environment manually:
#### Windows
```bash
.venv\Scripts\activate

```

#### macOS/Linux:
```bash
source .venv/bin/activate

```

### Key Advantages Over Anaconda

- [Visual Studio Code](#vscode)

| Feature | uv (Recommended) | Anaconda (Traditional) |
|:--- |:--- |:--- |
| Size | Lightweight | 3GB+ installation |
| Python Management | Automatic, multiple versions | Manual setup |
| Environment Mgmt. | Automatic | Manual activation required |
| Configuration | Modern pyproject.toml | Multiple config files |
| Package Ecosystem | Full PyPI access | Curated subset |

<!--#################################################-->

## Visual Studio Code IDE {#vscode}

Visual Studio Code (VS Code) is a free, powerful, and highly customizable code editor developed by Microsoft.  
It has become the most popular choice among Python developers due to its excellent Python support, rich extension ecosystem, and integrated development features.


### Why Choose VS Code?

- **Free and Open Source:** Completely free with no licensing restrictions  
- **Excellent Python Support:** Outstanding IntelliSense, debugging, and linting  
- **Rich Extension Ecosystem:** Thousands of extensions for every programming need  
- **Integrated Terminal:** Built-in terminal for running commands and scripts  
- **Git Integration:** Built-in version control with visual diff and merge tools  
- **Cross-Platform:** Available for Windows, macOS, and Linux  
- **Jupyter Support:** Native notebook editing and execution  


### Installation

1. Visit [code.visualstudio.com](https://code.visualstudio.com/)  
2. Download the installer for your operating system  
3. Install like any normal application  


### Essential Extensions for Python Data Science

After installing VS Code, you need to install the following extensions:

1. Click the **Extensions** icon in the sidebar (`Ctrl+Shift+X`)  
2. Search for the extension name  
3. Click **Install**  

**Core Python Extensions**  
1. Python (Microsoft) ‚Äì Essential Python support  
2. Pylance (Microsoft) ‚Äì Advanced Python language server  
3. Python Debugger (Microsoft) ‚Äì Python debugging support  

**Data Science Extensions**  
4. Jupyter (Microsoft) ‚Äì Jupyter notebook support  
5. Jupyter Keymap (Microsoft) ‚Äì Familiar Jupyter shortcuts  
6. Jupyter Notebook Renderers (Microsoft) ‚Äì Enhanced output rendering  

**Productivity Extensions**  
7. GitLens (GitKraken) ‚Äì Enhanced Git capabilities  
8. Bracket Pair Colorizer 2 ‚Äì Visual bracket matching  
9. indent-rainbow ‚Äì Visual indentation guides  
10. Ruff ‚Äì Extremely fast Python linter and code formatter  
11. Python Docstring Generator ‚Äì Automatic docstring generation  


### VS Code Configuration for Python

**Setting up Python Interpreter**  
1. Open Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P` on macOS)  
2. Type **Python: Select Interpreter**  
3. Choose your **uv-managed Python environment**  

**Recommended Settings**  
Create a `.vscode/settings.json` file in your project root:

```json
{
  "python.defaultInterpreterPath": "./.venv/bin/python", 
  // Windows: ".venv\\Scripts\\python.exe"
  "python.formatting.provider": "black",
  "python.linting.enabled": true,
  "python.linting.ruffEnabled": true, 
  "[python]": {
    "editor.codeActionsOnSave": {
      "source.fixAll.ruff": true // Auto-fix lint errors on save
    }
  },
  "jupyter.askForKernelRestart": false,
  "files.autoSave": "afterDelay"
}
```

## Getting Started with VS Code {#vscode}

Visual Studio Code (VS Code) is a lightweight editor that works seamlessly with Python projects.

### Open a Project
- Go to: **File ‚Üí Open Folder**
- Select your **uv project directory**

### Open Integrated Terminal
- Menu: **View ‚Üí Terminal**
- Shortcut: <kbd>Ctrl</kbd> + <kbd>`</kbd>

### Select Python Interpreter
1. Open Command Palette: <kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd>  
2. Search: **Python: Select Interpreter**  
3. Choose the interpreter from your **`.venv`** created by `uv`

### Select Kernel for Notebooks
1. Open your Jupyter Notebook file: `your-name-pre-course.ipynb`  
2. VS Code will prompt for a **kernel** (top-right corner)  
3. Choose the kernel from your **`.venv`** (e.g., Python 3.13.x installed via `uv`)

### Create a Python File
- Menu: **File ‚Üí New File**  
- Save as **`.py`**

### Run Python Code
- Right-click ‚Üí **Run Python File in Terminal**

### Run Code Line by Line (or by Cell)
- Place your cursor on a line (or select multiple lines)  
- Press <kbd>Shift</kbd> + <kbd>Enter</kbd>  
- Executes code in terminal or interactive window  
- Requires Python or Jupyter extension  

üí° *Tip: This is great for experimenting interactively without running the whole script.*


<!--#################################################-->

## Pre-Programme Assignment {#assignment}

1. **Download and unzip** the file `pre_programme_assignment.zip` into your `my-project` folder.  

   The archive contains:  
   - *Getting Started guide* (this file)  
   - *pre_programme.ipynb* (a Jupyter notebook)  

2. **Open the folder in VS Code**.  

3. **Work in `pre_programme.ipynb`:**  
   - Add your name  
   - Write a short biography in **Markdown**  
   - Fill out the provided code cells (you may adapt from DataCamp)  
   - Answer all written questions  

4. **When finished:**  
   - Click the **‚ÄúExport‚Äù** icon (box with arrow, top right in the notebook editor toolbar)  
   - From the dropdown, select **‚ÄúExport to HTML‚Äù**  
   - VS Code will generate the `.html` file (usually in the same folder)  

5. **Submit your work:**  
   - Upload the exported `.html` file to **Canvas** as your pre-programme submission  


::: callout-tip
üí° **Tip:** Make sure you have **uv installed** and your project opened in **VS Code** before starting the assignment.  
:::

<!--#################################################-->

# **Github**

::: {.callout-tip collapse=false}
## Contents
- [Using GitHub](#github)
:::

## Using GitHub {#github}

To get started with GitHub:

- Sign up at [github.com](https://github.com)
- Learn basic commands:
  - `git clone`
  - `git add`
  - `git commit`
  - `git push`
- Try GitHub Desktop if you're not comfortable with the command line interface (CLI)

<!--#################################################-->

# **Textbooks**


## Textbooks {#textbooks}

* <a href="https://leanpub.com/os" target="_blank">OpenIntro Statistics</a>
* <a href="https://byuidatascience.github.io/python4ds/" target="_blank">Python for Data Science</a>
* <a href="https://allendowney.github.io/ElementsOfDataScience/index.html" target="_blank">Elements of Data Science</a>

<!--#################################################-->

# **Data Sources**

::: {.callout-tip collapse=false}
## Contents
- [Finance Data](#finance)
- [World Bank](#worldBank)
:::

<!--#################################################-->

## Returns of Financial Stocks {#finance}

> You may find useful the material on [finance data sources](https://am01-sep24.netlify.app/reference/finance_data/).

We will use the `yfinance` package to download historical data of stock prices, calculate returns, and examine the distribution of returns.

Below are the imports and graph settings that we will be working with :
```python 
# Import required libraries

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import yfinance as yf
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Set style for better looking plots
plt.style.use('seaborn-v0_8')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (6.75, 6.75)
```


Before downloading data, we need to identify which stocks to track using their **ticker symbols**:  
- Apple ‚Üí `AAPL`  
- Microsoft ‚Üí `MSFT`  
- McDonald's ‚Üí `MCD`  

The file `nyse.csv` contains **508 stocks listed on the NYSE** with columns:  
- `symbol` ‚Üí ticker symbol  
- `name` ‚Üí company name  
- `ipo` ‚Üí IPO year  
- `sector` ‚Üí sector of the company  
- `industry` ‚Üí industry classification  

```python 
# Load NYSE data

nyse = pd.read_csv('../data/nyse.csv')

print(nyse.head())

print("nData info: ")

print(nyse.info())
```

Based on this dataset, create a table and a bar plot that shows the number of companies per sector, in descending order

```python 
# Companies per sector

sector_counts = nyse['sector'].value_counts()

print( "Companies per sector: ")

print(sector_counts)


# Bar plot

plt.figure(figsize=(12, 8))

sector_counts.plot(kind = 'bar')
plt.title('Number of Companies per Sector')
plt.xlabel('Sector')
plt.ylabel('Number of Companies')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()



# Reset index to make it suitable for seaborn plotting
sector_counts = sector_counts.reset_index()
sector_counts.columns = ['Sector', 'Number of Companies']

plt.figure(figsize=(12, 8))
sns.set_theme(style="whitegrid")

# Horizontal barplot with biggest sector at the top
sns.barplot(
    data=sector_counts,
    y='Sector',                     # Sectors on Y-axis (so bars are horizontal)
    x='Number of Companies',        # Counts on X-axis
    order=sector_counts['Sector']   # Order ensures sorting by count from top
)

plt.title('Number of Companies per Sector')
plt.xlabel('Number of Companies')
plt.ylabel('Sector')
plt.tight_layout()
plt.show()

```
See the output below:

![](Images/financeData1.png)
![](Images/financeData2.png)
Next, let's choose some stocks and their ticker symbols and download some data. You **MUST** choose 6 different stocks from the ones listed below; You should, however, add `SPY` which is the SP500 ETF (Exchange Traded Fund).


```python 
# List of stock symbols to download
my_stocks = ["AAPL",  "JPM",  "DIS",  "DPZ",  "ANF", "XOM", "SPY"]

# Dictionary to store each individual stock DataFrame
stock_data = {}

# Loop through each stock symbol
for symbol in my_stocks:
    try:
        # Download stock data with auto_adjust=False to include both 'Close' and 'Adj Close'
        stock = yf.download(
            symbol,
            start="2013-01-01",
            end="2024-08-31",
            auto_adjust=False,   # Ensures 'Adj Close' is included explicitly
            actions=True,        # Optional: includes dividends and splits if present
            progress=False
        )

        # Add stock symbol as a column to identify source
        stock['Symbol'] = symbol

        # Save stock DataFrame in dictionary
        stock_data[symbol] = stock

        # Print progress
        print(f"‚úÖ Downloaded {symbol}: {len(stock)} rows")

    except Exception as e:
        print(f"‚ö†Ô∏è Error downloading {symbol}: {e}")




# Combine all data

my_stocks_df = pd.concat(stock_data.values(), ignore_index=True)

print("nCombined data shape:", my_stocks_df.shape)
print("nData info:")
print(my_stocks_df.info())

my_stocks_df.head()


print(hist.columns)

```

Financial performance analysis depend on returns; If I buy a stock today for 100 and I sell it tomorrow for 101.75, my one-day return, assuming no transaction costs, is 1.75%. So given the adjusted closing prices, our first step is to calculate daily and monthly returns.

```python

# Calculate returns

returns_data = {}

for symbol in my_stocks:
    if symbol in stock_data:
        stock = stock_data[symbol]
        
        # Daily returns (log returns)
        stock['daily_returns'] = stock['Adj Close'].pct_change()
        
         # Monthly returns (arithmetic)
        stock['monthly_returns'] = stock['Adj Close'].resample('M').last().pct_change()
        
        # Yearly returns (arithmetic)
        stock['yearly_returns'] = stock['Adj Close'].resample('Y').last().pct_change()
        
        returns_data[symbol] = stock

print("Returns calculated for all stocks")

```

Returns calculated for all stocks

Now, create a table where you summarise monthly returns for each of the stocks and `SPY`; min, max, median, mean, SD.

```python 
# Summary of monthly returns

monthly_summary = {}

for symbol in my_stocks:
    if symbol in returns_data:
        monthly_returns = returns_data[symbol]['monthly_returns'].dropna()
        monthly_summary[symbol] = {
            
            'min': monthly_returns.min(),
            
            'max': monthly_returns.max(),
            
            'median': monthly_returns.median(),

            'mean': monthly_returns.mean(),

            'std': monthly_returns.std()
             
        }

monthly_summary_df = pd.DataFrame(monthly_summary).T.round(4)

print("Monthly returns summary:")
print(monthly_summary_df)

```

Plot a density plot, using `sns.kdeplot()`, for each of the stocks

```python 
# Density plot of monthly returns

plt.figure(figsize=(12, 8))

for symbol in my_stocks:
    if symbol in returns_data:
        monthly_returns = returns_data[symbol]['monthly_returns'].dropna()
        sns.kdeplot(monthly_returns, label=symbol, alpha=0.7)

plt.xlabel('Monthly Returns')
plt.ylabel('Density')
plt.title('Density Plot of Monthly Returns by Stock')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()


```
![](Images/financeData3.png)

What can you infer from this plot? Which stock is the riskiest? The least risky?


Finally, make a plot that shows the expected monthly return (mean) of a stock on the Y axis and the risk (standard deviation) in the X-axis. Please use `plt.annotate()` to label each stock

```python 
# Risk-return plot

plt.figure(figsize=(10, 8))

for symbol in my_stocks:
    if symbol in monthly_summary:
        risk = monthly_summary[symbol]['std']
        return_val = monthly_summary[symbol]['mean']
        plt.scatter(risk, return_val, s=100, alpha=0.7)
        plt.annotate(symbol, (risk, return_val), xytext=(5, 5), textcoords='offset points')


plt.xlabel('Risk (Standard Deviation)')
plt.ylabel('Expected Monthly Return (Mean)')
plt.title('Risk-Return Profile of Stocks')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()


```
![](Images/financeData4.png)
What can you infer from this plot? Are there any stocks which, while being riskier, do not have a higher expected return?


<!--#################################################-->

## World Bank {#worldBank}

- World Bank Open Data: [data.worldbank.org](https://data.worldbank.org)
- WDI R package: `WDI` on CRAN







